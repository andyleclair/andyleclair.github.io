<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/assets/app.css">
    <script type="text/javascript" src="/assets/app.js"></script>
    
    <title>Things You Can Do With Ecto</title>
    <meta name="description" content="Neat tricks I&#39;ve learned while working with Ecto">
  
  </head>

  <body class="bg-nor-easter text-smurf-blood">
    <div class="flex h-60 min-h-screen flex-col items-center">
      <header class="bg-bludacris p-10 my-4 lg:mt-10 lg:mb-14">
        <h1><a href="https://andyleclair.dev/">andy@andyleclair.dev</a>$><span class="blink">_</span></h1>
      </header>
      <main class="container mx-auto relative grow min-h-96 flex-1 p-4 items-center">
        
  <article class="mx-auto prose sm:prose-sm md:prose-md lg:prose-xl prose-pre:bg-codebg">
    <h1>Things You Can Do With Ecto</h1>
    <h3>Neat tricks I&#39;ve learned while working with Ecto</h3>
    <h3><a href="https://www.youtube.com/watch?v=SJnfdEX0QWk">Related Listening</a></h3>
    <p class="text-smurf-blood">Posted on 2025-01-21</p>
    <p>
I’ve been hard at work at my day job porting our analytics stack from Snowflake to Clickhouse. We’ve needed to port over our two existing query builders (one in Javascript, one Elixir)
to one system. We’re heavy users of Ecto, so naturally we would prefer to use the excellent <a href="https://github.com/plausible/ecto_ch">ecto_ch</a> library to interact with Clickhouse. This mostly works, but we’ve run into a few
limitations that have required us to get creative. Here are a few things I’ve learned along the way. </p>
<h2>
Fragment</h2>
<p>
<code class="inline">fragment</code> is an elegant escape hatch when you need to do something specific to your database. Clickhouse has a <em>ton</em> of specific functions, so we use <code class="inline">fragment</code> a lot.
We have a module that looks like this that we import, like <code class="inline">Ecto.Query</code>. For example, if you wanted to use Clickhouse’s <code class="inline">argMax</code> aggregate to get the <em>latest</em> value for a column, given some timestamp column (a common use-case), you could do this:</p>
<pre><code class="elixir">defmodule Clickhouse.Helpers do
  import Ecto.Query

  defmacro arg_max(column, timestamp) do
    quote do
      fragment(&quot;argMax(?, ?)&quot;, unquote(column), unquote(timestamp))
    end
  end
end</code></pre>
<p>
And this works! Let’s imagine you’re storing user profiles. The profiles are essentially a map with the keys and values broken out into separate columns.</p>
<p>
With a table schema like this:</p>
<pre><code class="elixir">defmodule MyApp.UserProfile do
  use Ecto.Schema

  schema &quot;user_profiles&quot; do
    field :user_id, :string
    field :key, :string
    field :value, :string
    field :timestamp, Ch, type: &quot;DateTime64(3)&quot;
  end
end</code></pre>
<p>
We will not update values, instead we will just write in new values whenever some attribute changes. You can easily get the latest values for each user with a query like this:</p>
<pre><code class="elixir">defmodule MyApp.Profiles do
  import Ecto.Query
  import Clickhouse.Helpers

  alias MyApp.UserProfile

  def latest_values do
    from p in UserProfile,
      select: %{
        user_id: p.user_id,
        key: p.key,
        value: arg_max(p.value, p.timestamp)
      },
      group_by: [p.user_id, p.key]
  end

end</code></pre>
<p>
The cool thing about <code class="inline">fragment</code> is that you can nest it! </p>
<pre><code class="elixir">defmacro map(key, value) do
  quote do
    fragment(&quot;map(?, ?)&quot;, unquote(key), unquote(value))
  end
end

defmacro max_map(col) do
  quote do
    fragment(&quot;maxMap(?)&quot;, unquote(col))
  end
end

def latest_profile do
  from q in subquery(
          from t in UserProfile,
            select: %{
              user_id: t.user_id,
              attrs: map(t.key, arg_max(t.value, t.timestamp))
            },
            group_by: [t.user_id]
        ),
        select: %{
          user_id: q.user_id, 
          profile: max_map(q.attrs)
        }
end</code></pre>
<p>
Now you’ve got Clickhouse rolling up the profiles and you’ll get a map back. Neat! I am going to spend <em>zero</em> time talking about why the function
in Clickhouse to merge nested maps is <code class="inline">maxMap</code> because <em>I do not know</em>. It simply is. But, you can see that composing these macros makes this super easy and the resulting Ecto query looks very close to what we’d get writing the query by hand. This is an especially useful property when you have a target query you’re working toward and you want to work backward from that into Ecto.</p>
<p>
That’s all well and good, but let’s say that you need to do some filtering. Let’s say we want to find the users with a specific profile value for a given key. If you want to filter on the <em>latest</em> values, you could do it with <code class="inline">having</code> (because <code class="inline">argMax</code> is an aggregate we need to use <code class="inline">having</code> not <code class="inline">where</code>):</p>
<pre><code class="elixir">@spec matching_users(String.t(), String.t()) :: Ecto.Query.t()
def matching_users(key, value) do
  from p in UserProfile,
    select: %{
      user_id: p.user_id,
      key: p.key,
      value: arg_max(p.value, p.timestamp) |&gt; selected_as(:value)
    },
    where: p.key == ^key,
    group_by: [p.user_id],
    having: selected_as(:value) == ^value
end</code></pre>
<p>
However, Clickhouse also provides aggregate combinators that you might want to use, such as <code class="inline">argMaxIfOrNull</code>. This combinator is like <code class="inline">argMax</code> but it has a third argument, a condition.</p>
<p>
This leads to my next thing I learned about <code class="inline">fragment</code>: you can pass in an <em>expression</em>.</p>
<pre><code class="elixir">defmacro arg_max_if_or_null(column, timestamp, condition) do
  quote do
    fragment(&quot;argMaxIfOrNull(?, ?, ?)&quot;, unquote(column), unquote(timestamp), unquote(condition))
  end
end

@spec users_with_latest_values([String.t()]) :: Ecto.Query.t()
def users_with_latest_values(attributes) do
  query =
    from p in UserProfile,
      select: %{user_id: p.user_id},
      group_by: [p.user_id]

  Enum.reduce(query, attributes, fn attr, query -&gt;
    from q in query,
      select_merge: %{
        ^attr =&gt; arg_max_if_or_null(q.value, q.timestamp, q.key == ^attr)
      }
  end)
end</code></pre>
<p>
As you can see, the third “argument” to <code class="inline">arg_max_if_or_null</code> is an expression, but it gets interpolated into <code class="inline">?</code> inside <code class="inline">fragment</code>. Incredible! This <em>just works!</em> When I figured this out, it really blew my mind, and I don’t think the docs mention it at all.</p>
<h2>
CTEs</h2>
<p>
If you work with analytical queries at all, you will probably encounter a CTE. These are also known as <code class="inline">with</code> statements. I’m not going to give a full primer on CTEs, but they’re a way to define a subquery that you can reference later in your query. Unfortunately for us, Clickhouse doesn’t materialize CTE results, so if you refer to the binding multiple times, the query gets run multiple times. I hear they’re working on it! That said, CTEs definitely still have a use and we use them. It was not immediately obvious to me from the docs how I could use a CTE, so here are some things I’ve learned.</p>
<h3>
You can pass <code class="inline">with_cte</code> a string!</h3>
<p>
The docs for <a href="https://hexdocs.pm/ecto/Ecto.Query.html#with_cte/3">with_cte</a> don’t say you can do this, but you can just name your CTE parts directly, with a string. This is a version
of the query from above, but using a CTE. Let’s make it a little more interesting of a query, and say we also need to go get the latest event for each of those users in order to sort the data and return the latest timestamp.</p>
<pre><code class="elixir">defmodule NeatEcto.Schemas.Events do
  use Ecto.Schema

  schema &quot;events&quot; do
    field :user_id, :string
    field :event_type, :string
    field :timestamp, Ch, type: &quot;DateTime64(3)&quot;
  end
end


def latest_profile_cte_version do
  attrs_query =
    from t in UserProfile,
      select: %{
        user_id: t.user_id,
        attrs: map(t.key, arg_max(t.value, t.timestamp))
      },
      group_by: [t.user_id]

  latest_events_query =
    from e in Events,
      select: %{
        user_id: e.user_id,
        latest_timestamp: max(e.timestamp)
      },
      group_by: [e.user_id]

  &quot;attr_pairs&quot;
  |&gt; with_cte(&quot;attr_pairs&quot;, as: ^attrs_query)
  |&gt; with_cte(&quot;latest_events&quot;, as: ^latest_events_query)
  |&gt; join(:inner, [a], e in &quot;latest_events&quot;, on: a.user_id == e.user_id)
  |&gt; select([a, e], %{
    user_id: a.user_id,
    latest_event: e.latest_timestamp,
    profile: max_map(a.attrs)
  })
  |&gt; order_by([a, e], desc: e.timestamp)
  |&gt; group_by([a, e], [a.user_id])
end</code></pre>
<p>
Of course, you could join on a subquery here, but I’m just trying to illustrate the specifics of using a CTE. It’s totally possible to dynamically build CTEs and that can be a super useful tool in building complex queries.</p>
<h2>
Cheating</h2>
<p>
Ok this last one is a little dirty. Maybe even <em>yucky</em>. Ecto expects that the developer is in charge of the naming of things and that those names are mostly available at compile time. There are few places where you can essentially allow for using
user input to name things (CTEs being one!), mostly you need to be using atoms, and every BEAM developer knows you shouldn’t dynamically create atoms because they’re never GC’d. That leads us to the following trick:</p>
<pre><code class="elixir"># Everything in life needs a limit
@substitutions for i &lt;- 0..100, into: %{}, do: {i, :&quot;subs_#{i}&quot;}
def substitutions, do: @substitutions

@spec latest_profiles([String.t()]) :: Ecto.Query.t()
def latest_profiles(keys) do
  substitutions = substitutions()
  base_query = from u in UserProfile, select: %{user_id: u.user_id}

  indexed_keys = Enum.with_index(keys)

  placeholders = for {name, i} &lt;- indexed_keys, into: %{}, do: {name, substitutions[i]}

  query =
    Enum.reduce(indexed_keys, base_query, fn {prop, i}, query -&gt;
      prop_placeholder = placeholders[i]

      select_merge(
        query,
        [p],
        %{
          ^prop_placeholder =&gt;
            arg_max_if_or_null(p.attribute_value, p.timestamp, p.attribute_name == ^prop)
        }
      )
    end)

  {query, placeholders}
end</code></pre>
<p>
What you <em>can</em> do is map your user provided list of strings to a list of atoms and then just hand back the mapping along with the query. Then, some enterprising developer could use the above <code class="inline">latest_profiles</code> query inside 
a subquery. This is really useful if you need to make sure that you’re able to compare on the results of the subquery externally and to make sure that the subquery only gets executed once. This technique can also be useful
if you need to return data in a specific column aliasing and it would be better to make the database do some calculation. You can execute the query and then use the placeholders to map back to the original key.</p>
<p>
It is an <em>extremely</em> niche use-case I know, however, it’s something I did run into in my day job. It’s useful to know how flexible Ecto can be! I try to coach my engineers to use Ecto as much as we can. There are <em>very</em>
few places where Ecto outright doesn’t work (perhaps fodder for another blog post) but you can get an absolutely insane amount of mileage out of it. It’s the best query builder I’ve ever used! Ecto forever.</p>
<p>
I hope this was useful to you. If you want to reach out, hit me up on Bluesky at <a href="https://bsky.app/profile/andyleclair.dev">andyleclair.dev</a> 🦋 </p>

  </article>

      </main>
      <footer class="mt-24 bg-bludacris p-4 text-center">
        © Andy LeClair 2024 | <a href="/atom.xml">Atom</a> | <a href="/feed.xml">RSS</a>
      </footer>
    </div>
  </body>
</html>