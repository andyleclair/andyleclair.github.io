<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/assets/app.css">
    <script type="text/javascript" src="/assets/app.js"></script>
    
    <title>Things You Can Do With Ecto</title>
    <meta name="description" content="Neat tricks I&#39;ve learned while working with Ecto">
  
  </head>

  <body class="bg-nor-easter text-smurf-blood">
    <div class="flex h-60 min-h-screen flex-col items-center">
      <header class="bg-bludacris p-10 my-4 lg:mt-10 lg:mb-14">
        <h1><a href="https://andyleclair.dev/">andy@andyleclair.dev</a>$><span class="blink">_</span></h1>
      </header>
      <main class="container mx-auto relative grow min-h-96 flex-1 p-4 items-center">
        
  <article class="mx-auto prose sm:prose-sm md:prose-md lg:prose-xl prose-pre:bg-codebg">
    <h1>Things You Can Do With Ecto</h1>
    <h3>Neat tricks I&#39;ve learned while working with Ecto</h3>
    <h3><a href="https://www.youtube.com/watch?v=SJnfdEX0QWk">Related Listening</a></h3>
    <p class="text-smurf-blood">Posted on 2025-01-21</p>
    <p>
I‚Äôve been hard at work at my day job porting our analytics stack from Snowflake to Clickhouse. We‚Äôve needed to port over our two existing query builders (one in Javascript, one Elixir)
to one system. We‚Äôre heavy users of Ecto, so naturally we would prefer to use the excellent <a href="https://github.com/plausible/ecto_ch">ecto_ch</a> library to interact with Clickhouse. This mostly works, but we‚Äôve run into a few
limitations that have required us to get creative. Here are a few things I‚Äôve learned along the way. </p>
<h2>
Fragment</h2>
<p>
<code class="inline">fragment</code> is an elegant escape hatch when you need to do something specific to your database. Clickhouse has a <em>ton</em> of specific functions, so we use <code class="inline">fragment</code> a lot.
We have a module that looks like this that we import, like <code class="inline">Ecto.Query</code>. For example, if you wanted to use Clickhouse‚Äôs <code class="inline">argMax</code> aggregate to get the <em>latest</em> value for a column, given some timestamp column (a common use-case), you could do this:</p>
<pre><code class="elixir">defmodule Clickhouse.Helpers do
  import Ecto.Query

  defmacro arg_max(column, timestamp) do
    quote do
      fragment(&quot;argMax(?, ?)&quot;, unquote(column), unquote(timestamp))
    end
  end
end</code></pre>
<p>
And this works! Let‚Äôs imagine you‚Äôre storing user profiles. The profiles are essentially a map with the keys and values broken out into separate columns.</p>
<p>
With a table schema like this:</p>
<pre><code class="elixir">defmodule MyApp.UserProfile do
  use Ecto.Schema

  schema &quot;user_profiles&quot; do
    field :user_id, :string
    field :key, :string
    field :value, :string
    field :timestamp, Ch, type: &quot;DateTime64(3)&quot;
  end
end</code></pre>
<p>
We will not update values, instead we will just write in new values whenever some attribute changes. You can easily get the latest values for each user with a query like this:</p>
<pre><code class="elixir">defmodule MyApp.Profiles do
  import Ecto.Query
  import Clickhouse.Helpers

  alias MyApp.UserProfile

  def latest_values do
    from p in UserProfile,
      select: %{
        user_id: p.user_id,
        key: p.key,
        value: arg_max(p.value, p.timestamp)
      },
      group_by: [p.user_id, p.key]
  end

end</code></pre>
<p>
The cool thing about <code class="inline">fragment</code> is that you can nest it! </p>
<pre><code class="elixir">defmacro map(key, value) do
  quote do
    fragment(&quot;map(?, ?)&quot;, unquote(key), unquote(value))
  end
end

defmacro max_map(col) do
  quote do
    fragment(&quot;maxMap(?)&quot;, unquote(col))
  end
end

def latest_profile do
  from q in subquery(
          from t in UserProfile,
            select: %{
              user_id: t.user_id,
              attrs: map(t.key, arg_max(t.value, t.timestamp))
            },
            group_by: [t.user_id]
        ),
        select: %{
          user_id: q.user_id, 
          profile: max_map(q.attrs)
        }
end</code></pre>
<p>
Now you‚Äôve got Clickhouse rolling up the profiles and you‚Äôll get a map back. Neat! I am going to spend <em>zero</em> time talking about why the function
in Clickhouse to merge nested maps is <code class="inline">maxMap</code> because <em>I do not know</em>. It simply is. But, you can see that composing these macros makes this super easy and the resulting Ecto query looks very close to what we‚Äôd get writing the query by hand. This is an especially useful property when you have a target query you‚Äôre working toward and you want to work backward from that into Ecto.</p>
<p>
That‚Äôs all well and good, but let‚Äôs say that you need to do some filtering. Let‚Äôs say we want to find the users with a specific profile value for a given key. If you want to filter on the <em>latest</em> values, you could do it with <code class="inline">having</code> (because <code class="inline">argMax</code> is an aggregate we need to use <code class="inline">having</code> not <code class="inline">where</code>):</p>
<pre><code class="elixir">@spec matching_users(String.t(), String.t()) :: Ecto.Query.t()
def matching_users(key, value) do
  from p in UserProfile,
    select: %{
      user_id: p.user_id,
      key: p.key,
      value: arg_max(p.value, p.timestamp) |&gt; selected_as(:value)
    },
    where: p.key == ^key,
    group_by: [p.user_id],
    having: selected_as(:value) == ^value
end</code></pre>
<p>
However, Clickhouse also provides aggregate combinators that you might want to use, such as <code class="inline">argMaxIfOrNull</code>. This combinator is like <code class="inline">argMax</code> but it has a third argument, a condition.</p>
<p>
This leads to my next thing I learned about <code class="inline">fragment</code>: you can pass in an <em>expression</em>.</p>
<pre><code class="elixir">defmacro arg_max_if_or_null(column, timestamp, condition) do
  quote do
    fragment(&quot;argMaxIfOrNull(?, ?, ?)&quot;, unquote(column), unquote(timestamp), unquote(condition))
  end
end

@spec users_with_latest_values([String.t()]) :: Ecto.Query.t()
def users_with_latest_values(attributes) do
  query =
    from p in UserProfile,
      select: %{user_id: p.user_id},
      group_by: [p.user_id]

  Enum.reduce(query, attributes, fn attr, query -&gt;
    from q in query,
      select_merge: %{
        ^attr =&gt; arg_max_if_or_null(q.value, q.timestamp, q.key == ^attr)
      }
  end)
end</code></pre>
<p>
As you can see, the third ‚Äúargument‚Äù to <code class="inline">arg_max_if_or_null</code> is an expression, but it gets interpolated into <code class="inline">?</code> inside <code class="inline">fragment</code>. Incredible! This <em>just works!</em> When I figured this out, it really blew my mind, and I don‚Äôt think the docs mention it at all.</p>
<h2>
CTEs</h2>
<p>
If you work with analytical queries at all, you will probably encounter a CTE. These are also known as <code class="inline">with</code> statements. I‚Äôm not going to give a full primer on CTEs, but they‚Äôre a way to define a subquery that you can reference later in your query. Unfortunately for us, Clickhouse doesn‚Äôt materialize CTE results, so if you refer to the binding multiple times, the query gets run multiple times. I hear they‚Äôre working on it! That said, CTEs definitely still have a use and we use them. It was not immediately obvious to me from the docs how I could use a CTE, so here are some things I‚Äôve learned.</p>
<h3>
You can pass <code class="inline">with_cte</code> a string!</h3>
<p>
The docs for <a href="https://hexdocs.pm/ecto/Ecto.Query.html#with_cte/3">with_cte</a> don‚Äôt say you can do this, but you can just name your CTE parts directly, with a string. This is a version
of the query from above, but using a CTE. Let‚Äôs make it a little more interesting of a query, and say we also need to go get the latest event for each of those users in order to sort the data and return the latest timestamp.</p>
<pre><code class="elixir">defmodule NeatEcto.Schemas.Events do
  use Ecto.Schema

  schema &quot;events&quot; do
    field :user_id, :string
    field :event_type, :string
    field :timestamp, Ch, type: &quot;DateTime64(3)&quot;
  end
end


def latest_profile_cte_version do
  attrs_query =
    from t in UserProfile,
      select: %{
        user_id: t.user_id,
        attrs: map(t.key, arg_max(t.value, t.timestamp))
      },
      group_by: [t.user_id]

  latest_events_query =
    from e in Events,
      select: %{
        user_id: e.user_id,
        latest_timestamp: max(e.timestamp)
      },
      group_by: [e.user_id]

  &quot;attr_pairs&quot;
  |&gt; with_cte(&quot;attr_pairs&quot;, as: ^attrs_query)
  |&gt; with_cte(&quot;latest_events&quot;, as: ^latest_events_query)
  |&gt; join(:inner, [a], e in &quot;latest_events&quot;, on: a.user_id == e.user_id)
  |&gt; select([a, e], %{
    user_id: a.user_id,
    latest_event: e.latest_timestamp,
    profile: max_map(a.attrs)
  })
  |&gt; order_by([a, e], desc: e.timestamp)
  |&gt; group_by([a, e], [a.user_id])
end</code></pre>
<p>
Of course, you could join on a subquery here, but I‚Äôm just trying to illustrate the specifics of using a CTE. It‚Äôs totally possible to dynamically build CTEs and that can be a super useful tool in building complex queries.</p>
<h2>
Cheating</h2>
<p>
Ok this last one is a little dirty. Maybe even <em>yucky</em>. Ecto expects that the developer is in charge of the naming of things and that those names are mostly available at compile time. There are few places where you can essentially allow for using
user input to name things (CTEs being one!), mostly you need to be using atoms, and every BEAM developer knows you shouldn‚Äôt dynamically create atoms because they‚Äôre never GC‚Äôd. That leads us to the following trick:</p>
<pre><code class="elixir"># Everything in life needs a limit
@substitutions for i &lt;- 0..100, into: %{}, do: {i, :&quot;subs_#{i}&quot;}
def substitutions, do: @substitutions

@spec latest_profiles([String.t()]) :: Ecto.Query.t()
def latest_profiles(keys) do
  substitutions = substitutions()
  base_query = from u in UserProfile, select: %{user_id: u.user_id}

  indexed_keys = Enum.with_index(keys)

  placeholders = for {name, i} &lt;- indexed_keys, into: %{}, do: {name, substitutions[i]}

  query =
    Enum.reduce(indexed_keys, base_query, fn {prop, i}, query -&gt;
      prop_placeholder = placeholders[i]

      select_merge(
        query,
        [p],
        %{
          ^prop_placeholder =&gt;
            arg_max_if_or_null(p.attribute_value, p.timestamp, p.attribute_name == ^prop)
        }
      )
    end)

  {query, placeholders}
end</code></pre>
<p>
What you <em>can</em> do is map your user provided list of strings to a list of atoms and then just hand back the mapping along with the query. Then, some enterprising developer could use the above <code class="inline">latest_profiles</code> query inside 
a subquery. This is really useful if you need to make sure that you‚Äôre able to compare on the results of the subquery externally and to make sure that the subquery only gets executed once. This technique can also be useful
if you need to return data in a specific column aliasing and it would be better to make the database do some calculation. You can execute the query and then use the placeholders to map back to the original key.</p>
<p>
It is an <em>extremely</em> niche use-case I know, however, it‚Äôs something I did run into in my day job. It‚Äôs useful to know how flexible Ecto can be! I try to coach my engineers to use Ecto as much as we can. There are <em>very</em>
few places where Ecto outright doesn‚Äôt work (perhaps fodder for another blog post) but you can get an absolutely insane amount of mileage out of it. It‚Äôs the best query builder I‚Äôve ever used! Ecto forever.</p>
<p>
I hope this was useful to you. If you want to reach out, hit me up on Bluesky at <a href="https://bsky.app/profile/andyleclair.dev">andyleclair.dev</a> ü¶ã </p>

  </article>

      </main>
      <footer class="mt-24 bg-bludacris p-4 text-center">
        ¬© Andy LeClair 2024 | <a href="/atom.xml">Atom</a> | <a href="/feed.xml">RSS</a>
      </footer>
    </div>
  </body>
</html>